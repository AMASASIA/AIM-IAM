import { firestore } from '../firebase';
import { collection, addDoc, updateDoc, doc, serverTimestamp, query, orderBy, limit, getDocs } from 'firebase/firestore';

const API_BASE_URL = 'http://localhost:8000';

/**
 * AIM3 Unified Action Delegation Service (Phase B: Semantic Index & recall)
 * 「脳（Gemini）」の決定を「手足（Task/API）」に伝え、「記憶（Vector）」に刻み、意志を「想起（Recall）」する。
 */
export const UnifiedService = {

    /**
     * タスクの完了実行 ＋ セマンティック・インデックス保存
     */
    async completeAndRecordWill(taskData, userWill = "") {
        try {
            console.log(`[AIM3] Executing delegation for task: ${taskData.title}`);

            // 1. Mark as completed in Firestore
            if (taskData.id && !taskData.id.startsWith('temp-')) {
                const taskRef = doc(firestore, "tasks", taskData.id);
                await updateDoc(taskRef, {
                    status: "completed",
                    completedAt: serverTimestamp(),
                    lastContext: userWill
                });
            }

            // 2. Extract Meaning (via Backend Embedding)
            const semanticContent = `
        TASK: ${taskData.title}
        DESCRIPTION: ${taskData.description || "N/A"}
        USER_WILL: ${userWill}
        CATEGORY: ${taskData.category || "general"}
        STATUS: Successfully Completed
      `;

            const response = await fetch(`${API_BASE_URL}/ai/generate-embedding`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text: semanticContent })
            });
            const { embedding } = await response.json();

            // 3. Save to Semantic Index (Firestore Vector Search)
            const memoryRef = collection(firestore, "semantic_memories");
            await addDoc(memoryRef, {
                originalTaskId: taskData.id || 'none',
                content: semanticContent,
                embedding: embedding,
                metadata: {
                    type: "task_completion",
                    title: taskData.title,
                    importance: taskData.priority || "normal",
                    timestamp: new Date().toISOString()
                }
            });

            return { success: true, memoryId: memoryRef.id };
        } catch (error) {
            console.error("[AIM3] Critical Error in UnifiedService (Index):", error);
            throw error;
        }
    },

    /**
     * Recall & Execute Will (Autonomous Action Engine)
     */
    async recallAndExecuteWill(userPrompt) {
        try {
            console.log(`[AIM3] Recalling memories for: "${userPrompt}"`);

            // 1. Get query vector from backend
            const vecResponse = await fetch(`${API_BASE_URL}/ai/generate-embedding`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ text: userPrompt })
            });
            const { embedding } = await vecResponse.json();

            // 2. Search similar memories
            const memories = await this._searchSimilarMemories(embedding);

            // 3. Generate Action Plan via Backend Orchestrator
            const recallResponse = await fetch(`${API_BASE_URL}/ai/recall-will`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ prompt: userPrompt, context_memories: memories })
            });
            const actionPlan = await recallResponse.json();

            // 4. Autonomous Task creation
            const newTaskRef = await addDoc(collection(firestore, "tasks"), {
                ...actionPlan,
                status: "pending",
                createdAt: serverTimestamp(),
                isAutoGenerated: true,
                sourcePrompt: userPrompt
            });

            return { success: true, task: actionPlan, taskId: newTaskRef.id };
        } catch (error) {
            console.error("[AIM3] Critical Error in UnifiedService (Recall):", error);
            throw error;
        }
    },

    async _searchSimilarMemories(vector) {
        try {
            const memoriesRef = collection(firestore, "semantic_memories");
            const q = query(memoriesRef, orderBy("metadata.timestamp", "desc"), limit(3));
            const querySnapshot = await getDocs(q);
            return querySnapshot.docs.map(doc => doc.data());
        } catch (e) {
            return [];
        }
    }
};

export default UnifiedService;
